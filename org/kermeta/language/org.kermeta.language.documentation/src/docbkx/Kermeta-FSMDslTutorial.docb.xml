<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<!-- $Id$ -->
<book lang="en-US">
	<bookinfo>
		<mediaobject>
			<imageobject>
				<imagedata fileref="Kermeta-Manual_figures/KermetaLogo.png"
					format="PNG" />
			</imageobject>
		</mediaobject>
		<title>Use case of Kermeta 2</title>
		<subtitle>Finite state machine sample</subtitle>

		<pubdate>Build
			: &version; &buildNumber;
		</pubdate>
		<date>$Date:: $</date>
		
		<author>
			<firstname>Fabien</firstname>
			<surname>Coulon</surname>
		</author>

		<keywordset>
			<keyword>Kermeta</keyword>
			<keyword>metamodeling</keyword>
			<keyword>language</keyword>
			<keyword>dsl</keyword>
			<keyword>FSM</keyword>
			<keyword>sample</keyword>
		</keywordset>

		<abstract>
			<para>Kermeta is a Domain Specific Language dedicated to metamodel engineering. It fills the gap let by MOF which defines only the structure of metamodels, by adding a way to specify static semantic (similar to OCL) and dynamic semantic (using operational semantic in the operation of the metamodel). Kermeta uses the object-oriented paradigm like Java or Eiffel.This document presents various aspects of the language, including the textual syntax, the metamodel (which can be viewed as the abstract syntax) and some more advanced features typically included in its framework. </para>
			<para>In this tutorial we will show how Kermeta 2 can help you to add sematic on your own model, how to transform it to another model and how to build a basic interpreter.</para>
		</abstract>

		<publisher>
			<publishername>INRIA</publishername>

			<address>
				<state>France</state>
				<otheraddr>
					<ulink url="http://www.inria.fr">http://www.inria.fr</ulink>
				</otheraddr>
			</address>
		</publisher>
	</bookinfo>

	<preface id="preface.link">
		<title id="preface.title.link">
			Presentation
			<phrase id="preface"></phrase>
		</title>
		<para>Kermeta action language is a DSL designed to manipulate
			models. However it
			isn't a general purpose language and thus doesn't
			directly offer all
			the libraries to build for example an application 
			with a
			sophisticated GUI.
		</para>

		<important>
			<title>Prerequisite</title>
			<para>Preconditions so that the tutorials could run correctly</para>
			<itemizedlist>
				<listitem>
					<para>Use an Eclipse Modeling Tools based on a Juno version</para>
				</listitem>
				<listitem>
					<para>On Eclipse IDE should be installed Kermeta language plug-in
						based upon a Release version
					</para>
				</listitem>
				<listitem>
					<para>On Eclipse IDE should be installed Maven plug-in</para>
				</listitem>
				<listitem>
					<para>Eclipse must be started using a JDK (not a JRE). This must be
						specified in the eclipse.ini file using the -vm option.
					</para>
				</listitem>
			</itemizedlist>
			<para>Alternatively to the first 3 points, you can use the predefined
				eclipse package with all kermeta tools preinstalled.
			</para>
		</important>
	</preface>
	
	<chapter>
		<title>Introduction</title>
		<para>
		This tutorial gives an overview of many concepts used through Kermeta 2 project creation.
		</para>
		<para>To illustrate the use of Kermeta 2, we will study the case of a Finite state machine(FSM).
		At the end of this tutorial you will know how to use Kermeta 2 for :
		</para>
		<para> 
			<itemizedlist>
				<listitem>
					<para>Import a model in Kermeta 2</para>
				</listitem>
				<listitem>
					<para>Adding constaints on your model</para>
				</listitem>
				<listitem>
					<para>Browsing your model</para>
				</listitem>
				<listitem>
					<para>Adding behavior on your model</para>
				</listitem>
				<listitem>
					<para>Make a running application based on your model</para>
				</listitem>
			</itemizedlist>
		</para>
	</chapter>
	
	<chapter>
		<title>Define the FSM metamodel</title>
		<para> An I/O state machine  is composed with two kind of elements: states and transitions which linking them. There is a current state in the machine, which begin on the initial state end finish on the final state. The current state move between states by following transitions. A transition is followed if the input is read. And if transition is followed the ouput is writed</para>
		<para>
			This example recognizes the "hello!" motif and produces the "world!" motif. Here, we present this finite-state machine in a specific graphical syntax where states are squares and transitions are arrows between squares. Input and outputs are present above transitions. Here, "h/w" says that we consume an "h" to produce a "w"
			<mediaobject>
				<imageobject>
					<imagedata
						fileref="Kermeta-FSMDslTutorial_figures/helloWorldFSM.png"
						format="PNG" />
				</imageobject>
			</mediaobject>
		</para>
		<para>
			Because of a good diagram is more efficient than a long description, have a look at this metamodel:
			<mediaobject>
				<imageobject>
					<imagedata
						fileref="Kermeta-FSMDslTutorial_figures/FSMBeginningMM.png"
						format="PNG" />
				</imageobject>
			</mediaobject>
		</para>
	</chapter>
	
	<chapter>
		<title>Models &amp; Metamodel</title>
		<para> In this section we will define, with EMF, the metamodel and make a simple editor to create some conforms models, which will be the input of Kermeta 2. You can do this works with Kermeta language but this is not the purpose of this tutorial, here we want show how the 2 technologies work together</para>
		
		<section id="metamodel">
			<title>Creation of the metamodel</title>
			<para>
				The first step is to make the .ecore file, which will describe your metamodel.
				Create a new project in File -> New -> Project and in "Eclipse Modeling Framework" select "Empty EMF Project". 
				<mediaobject>
					<imageobject>
						<imagedata
							fileref="Kermeta-FSMDslTutorial_figures/1_empty_project.png"
							format="PNG" />
					</imageobject>
				</mediaobject>
				Name your project "model".
				<mediaobject>
					<imageobject>
						<imagedata
							fileref="Kermeta-FSMDslTutorial_figures/2_name_empty_project.png"
							format="PNG" />
					</imageobject>
				</mediaobject>
				The project appear now in your workspace.
				<mediaobject>
					<imageobject>
						<imagedata
							fileref="Kermeta-FSMDslTutorial_figures/3_empty_project_created.png"
							format="PNG" />
					</imageobject>
				</mediaobject>
				Then create the .ecore file with a right clic on your project and select New -> Other. Choose "Ecore Model" in "Eclipse Modeling Framework".
				<mediaobject>
					<imageobject>
						<imagedata
							fileref="Kermeta-FSMDslTutorial_figures/4_add_ecore.png"
							format="PNG" />
					</imageobject>
				</mediaobject>
				Name your file fsm.ecore and put it in the "model" folder of your project.
				<mediaobject>
					<imageobject>
						<imagedata
							fileref="Kermeta-FSMDslTutorial_figures/5_name_ecore.png"
							format="PNG" />
					</imageobject>
				</mediaobject>
				Select "EPackage" and clic on finish.
				<mediaobject>
					<imageobject>
						<imagedata
							fileref="Kermeta-FSMDslTutorial_figures/6_type_ecore.png"
							format="PNG" />
					</imageobject>
				</mediaobject>
				Your .ecore is created, we must fill it now !
				<mediaobject>
					<imageobject>
						<imagedata
							fileref="Kermeta-FSMDslTutorial_figures/7_project_with_ecore.png"
							format="PNG" />
					</imageobject>
				</mediaobject>
				Open fsm.ecore with the "Sample Ecore Model Editor". It is the default Eclipse editor for .ecore file.
				Then do a right clic on the fsm package in the model and in "New Child" select "EClass" to create the three mains elements of our model: FSM, State and Transition.
				<mediaobject>
					<imageobject>
						<imagedata
							fileref="Kermeta-FSMDslTutorial_figures/8_ecore_classes.png"
							format="PNG" />
					</imageobject>
				</mediaobject>
				<para>We will creates attributes and references for the State. Reference types are related to EClass whereas EAttributes are simple types.</para>
				<para>Open the Properties view in "Window" -> "Show view" -> "Other" and "Properties" in "General" folder. This view is useful to edit attributes of model elements.</para>
				<para>Right clic on State, New Child and clic on EAttribute. Set "name" as Name of the EAttibute created.</para>
				 
				<para>Create three other EReference for the State and name them "outgoingTransition", "incomingTransition" and "owningFSM". 
				You can change the cardinality with "Lower" and "Upper Bound", where -1 means infinity.
				Set the EType for each one. We will also set EOpposite values after we have defined attributes of others Classes.</para> 
				
				
				
				<para>I let you to finish yourself the fsm.ecore according to the "Define the FSM metamodel" section.
				You can get the solution in the subsection "Getting the solution: the FSM sample" of the last chapter of this tutorial.</para>
				<mediaobject>
					<imageobject>
						<imagedata
							fileref="Kermeta-FSMDslTutorial_figures/9_ecore_attributes.png"
							format="PNG" />
					</imageobject>
				</mediaobject>
				Now we suppose your fsm.ecore looks like mine in the screenshot.
				<mediaobject>
					<imageobject>
						<imagedata
							fileref="Kermeta-FSMDslTutorial_figures/10_ecore_full.png"
							format="PNG" />
					</imageobject>
				</mediaobject>
			</para>
		</section>
		<section id="genmodel">
			<title>Make instances models</title>
			<para>In this chapter we present how to create instances of the Fsm metamodel. You can use two ways to do that, creating dynamic instances directly or using an EMF tree editor.</para>
			<section id="Dynamic instances">
				<title>Dynamic instances</title>
				<para>
					Create a dynamic instance is an easy way to create an instance of a metamodel during the first development phases. To do so :
					<itemizedlist>
						<listitem>Open the fsm.ecore file with the Sample Ecore Model Editor (Right click on the file -> Open with -> Sample Reflective Ecore Model Editor)</listitem>
						<listitem>Then, right click on the FSM metaclass -> Create Dynamic Instance and select a folder. Name your instance fsm.xmi.</listitem>
					</itemizedlist> 
					
					<mediaobject>
						<imageobject>
							<imagedata
								fileref="Kermeta-FSMDslTutorial_figures/create_dynamic_instance.png"
								format="PNG" />
						</imageobject>
					</mediaobject>
					
					Open this instance with the Sample Reflexive Ecore Model Editor (like shown above). You can add two State st1 and st2 on the FSM class and then a transition 'a' that produce 'b' between st1 and st2 like in the following image : 
					<mediaobject>
						<imageobject>
							<imagedata
								fileref="Kermeta-FSMDslTutorial_figures/example_dynamic_instance.png"
								format="PNG" />
						</imageobject>
					</mediaobject>
				</para>
			</section>
			<section id="editor">
				<title>Tree view editor</title>
				<section>
					<title>Generate the editor </title>
						<para>We will now create the .genmodel file. This is a code generator based on an .ecore file. It makes a Java implementation of your metamodel and can generate a simple editor, with which you will create instances of your metamodel.</para>
						<para>Right clic on your project and select New -> Other, and "EMF Generator Model" in "Eclipse Modeling Framework".</para>
						<mediaobject>
							<imageobject>
								<imagedata
									fileref="Kermeta-FSMDslTutorial_figures/11_create_genmodel.png"
									format="PNG" />
							</imageobject>
						</mediaobject>
						
						<para>Name it "fsm.genmodel".</para>
						
						<mediaobject>
							<imageobject>
								<imagedata
									fileref="Kermeta-FSMDslTutorial_figures/12_name_genmodel.png"
									format="PNG" />
							</imageobject>
						</mediaobject>
						
						<para>Base on Ecore model.</para>
						
						<mediaobject>
							<imageobject>
								<imagedata
									fileref="Kermeta-FSMDslTutorial_figures/13_type_import_genmodel.png"
									format="PNG" />
							</imageobject>
						</mediaobject>
						
						<para>Select "fsm.ecore" from your workspace.</para>
						
						<mediaobject>
							<imageobject>
								<imagedata
									fileref="Kermeta-FSMDslTutorial_figures/14_import_ecore_genmodel.png"
									format="PNG" />
							</imageobject>
						</mediaobject>
						
						<para>Then clic on Finish.</para>
						
						<mediaobject>
							<imageobject>
								<imagedata
									fileref="Kermeta-FSMDslTutorial_figures/15_package_genmodel.png"
									format="PNG" />
							</imageobject>
						</mediaobject>
						
						<para>
						Once you have the genmodel, in the Properties view go to Edit section of "ownedState" of FSM to allow creation of Children in the editor.
						Do the same operation for "outgoingTransition" of State.
						</para>
						
						<mediaobject>
							<imageobject>
								<imagedata
									fileref="Kermeta-FSMDslTutorial_figures/16_edit_genmodel.png"
									format="PNG" />
							</imageobject>
						</mediaobject>
						
						<para>
						Right clic on the root node of the genmodel and select Generate All. This will generate Java classes implementation of the .ecore in the "src" folder of your project.
						The two projects generated "model.edit" and "model.editor" will be used as Eclipse plugin and are the implementation of your model editor.
						</para>
						
						<mediaobject>
							<imageobject>
								<imagedata
									fileref="Kermeta-FSMDslTutorial_figures/17_generate_all_genmodel.png"
									format="PNG" />
							</imageobject>
						</mediaobject>
					</section>
					
					<section>
						<title>Use the editor</title>
						<para>
						Right clic on "model.editor" and Run as -> Eclipse Application. 
						Create a new empty project in your new instance of Eclipse (where your editor is running as a pluging).
						Then go to File -> New -> Other -> Example EMF Model Creation Wizard and select Fsm Model.
						</para>
						
						<mediaobject>
							<imageobject>
								<imagedata
									fileref="Kermeta-FSMDslTutorial_figures/18_create_model_editor.png"
									format="PNG" />
							</imageobject>
						</mediaobject>
						
						<para>Give a name to your model. (note: the extension of your model file is the name of your metamodel)</para>
						
						<mediaobject>
							<imageobject>
								<imagedata
									fileref="Kermeta-FSMDslTutorial_figures/19_name_model_editor.png"
									format="PNG" />
							</imageobject>
						</mediaobject>
						
						<para>Set "FSM" as a type of object model.</para>
						
						<mediaobject>
							<imageobject>
								<imagedata
									fileref="Kermeta-FSMDslTutorial_figures/20_type_model_editor.png"
									format="PNG" />
							</imageobject>
						</mediaobject>
						
						<para>Then you can add elements in the model with right clic -> New Child. Your editor will propose you object of the right allowed type.</para>
						
						<mediaobject>
							<imageobject>
								<imagedata
									fileref="Kermeta-FSMDslTutorial_figures/21_edit_model.png"
									format="PNG" />
							</imageobject>
						</mediaobject>
					</section>

			</section>
			<para>Congratulation you have build a simple editor from your metamodel !</para>
		</section>
		<para>For more informations about EMF modeling go to "http://www.eclipse.org/documentation/", choose your version of Eclipse and select EMF Developer Guide -> Tutorials</para>
	</chapter>
	
	<chapter>
		<title>Adding constraints on the model</title>
		<para> TODO: not yet working on K2 but explain the OCL-like feature and for what is it. Ex: not duplicated transitions allowed</para>
		<section id="Creation of the project">
			<title>Creation of the project</title>
		</section>
		<section>
			<title>Run configurations</title>
			<section>
				<title>An entry point for the program</title>
			</section>
			<section>
				<title>Execution without parameters</title>
			</section>
			<section>
				<title>Execution with parameter(s)</title>
			</section>
		</section>
	</chapter>
	
	<chapter>
		<title>Make the machine alive</title>
		<para> TODO: explain how to write the interpreter and what is it</para>
		<section id="Adding behavior">
			<title>Adding behavior in theory</title>
			<section id="Expercted behavior">
				<title>Expected behaviour for this tutorial</title>
				<para>
					Adding a behaviour to the FSM meta-model consists in to do a simulation of execution with operations and an execution context represented by the current state of the FSM. That's why you need to add a currentState reference and three operation : 
					<itemizedlist>
						<listitem>
							<para>run() for FSM class</para>
						</listitem>
						<listitem>
							<para>step(String): String for State class</para>
						</listitem>
						<listitem>
							<para>and fire(): String for Transition class </para>
						</listitem>
					</itemizedlist>
					Adding behavior to this meta model look like change the meta model according the following schema : 					
					<mediaobject>
						<imageobject>
							<imagedata
								fileref="Kermeta-FSMDslTutorial_figures/FSMBehaviorMM.png"
								format="PNG" />
						</imageobject>
					</mediaobject>
				</para>
			</section>
			<section id="Behavior algorithms">
				<title>Behavior algorithms</title>
				<section>
					<title>Run algorithm</title>
					<itemizedlist>
						<listitem>
							<para>initialize current state</para>
						</listitem>
						<listitem>
							<para>
							loop until the user's input equal to "quit"
							<itemizedlist>
								<listitem>print the current state</listitem>
								<listitem>read a string</listitem>
								<listitem>process a step</listitem>
								<listitem>catch exceptions if there are some and exit the program displaying the error</listitem>
							</itemizedlist>
							</para>
						</listitem>
					</itemizedlist>
				</section>
				<section>
					<title>Step algorithm </title>
					<itemizedlist>
						<listitem>
							<para>Select the possible transitions</para>
						</listitem>
						<listitem>
							<para>If there is none</para>
							<itemizedlist>
								<listitem><para>Raise a NoTransition exception</para></listitem>
							</itemizedlist>
						</listitem>
						<listitem>
							<para>If there is more than one</para>
							<itemizedlist>
								<listitem><para>Raise a NonDeterminism exception</para></listitem>
							</itemizedlist>
						</listitem>
						<listitem>
							<para>If there is only one transition</para>
							<itemizedlist>
								<listitem><para>Call its fire operation and return its result</para></listitem>
							</itemizedlist>
						</listitem>
					</itemizedlist>
				</section>
				<section>
					<title>Fire algorithm </title>
					<para>
						<itemizedlist>
							<listitem>Change the current state of the FSM</listitem>
							<listitem>Return the produced string</listitem>
						</itemizedlist>
					</para>
				</section>
			</section>
			<section id="Aspect behavior">
				<title>Add this behavior with aspects</title>
				<para>
					Kermeta offer a simple way to implement behavior: the aspects.
					With aspect, you can add new elements and new operations to a fixed meta-model. 
					You can also combine several aspects. This section show you how to add behaviour with aspect into a metamodel.
				</para>
				<para>
					We illustrate this by an example on the FSM class:
					<programlisting language="kermeta">
using fsm::*
using kermeta::standard::*
using kermeta::io::StdIO => stdio

aspect class FSM 
{

	reference currentState : State
	
	operation run() :  Void raises FSMException is do 
		// [...]
	 end 
	
	operation initialize(p_state : State, isInitComb : Boolean) is do
		// [...]
	end 
} 
					</programlisting>
					<itemizedlist>
						<listitem>
							<para>The key word using permits to simplify the writing of the elements from the fsm meta model like an import in the Java language.</para>
						</listitem>
						<listitem>
							<para>The key word aspect is used to add attributes or operations to an existing metaclass of the loaded meta model.</para>
						</listitem>
					</itemizedlist>
				</para>
			</section>
		</section>
		<section id="Adding behavior K2">
			<title>Adding behavior in Kermeta 2</title>
			<section id="Creation of the project K2">
				<title>Creation of the project</title>
				<para>
					First create a new Kermeta 2 project in File -> New -> Project -> Kermeta -> Kermeta project.
					<mediaobject>
						<imageobject>
							<imagedata
								fileref="Kermeta-FSMDslTutorial_figures/22_create_kermeta_project.png"
								format="PNG" />
						</imageobject>
					</mediaobject>
					And name it "simulation"
					<mediaobject>
						<imageobject>
							<imagedata
								fileref="Kermeta-FSMDslTutorial_figures/23_name_kermeta_project.png"
								format="PNG" />
						</imageobject>
					</mediaobject>
				</para>
				
				<para>The project contains "project.kp" and "src/main/kmt/MainClass.kmt".</para>
				
				<para>
				"MainClass.kmt" define one method which print "Hello world!". 
				<programlisting language="kermeta">
using kermeta::standard::*
using kermeta::io::StdIO => stdio

package mainPackage{
	class MainClass
	{

		@main "" // declares that operation as a possible entry point of the program
		operation mainOperation() : Void is do 
			// TODO: implement 'mainOperation' operation
			stdio.writeln("Hello from mainOperation")
		end
	}
}
				</programlisting>
				</para>
				
				<para>
				The "project.kp" declare all the content of your project:
				<itemizedlist>
					<listitem>Import the kermeta metamodel where are defined all elements of the language</listitem>
					<listitem>Where is the main method</listitem>
					<listitem>"MainClass.kmt" is a source file of your project</listitem>
				</itemizedlist> 
				<programlisting language="kermeta">
resource library_standard ="platform:/plugin/org.kermeta.language.library.standard" alternative "mvn:org.kermeta.language/org.kermeta.language.library.standard/2.0.99-SNAPSHOT"
importProject library_standard
project simulation {
	mainClass "simulation^mainPackage::MainClass"
	mainOperation "mainOperation"

	import "${project.baseUri}/src/main/kmt/MainClass.kmt"
}
				</programlisting> 
				</para>
				
				<para>
				Now we want to import our model. To do that we add a ressource delcaration at the top of the kp:
				<programlisting language="kermeta">
resource fsm_model = "mvn:org.kermeta.language.sample.fsm/org.kermeta.language.sample.fsm.model/1.0.0-SNAPSHOT"
				</programlisting>
				Then we say to Kermeta this model is a part of our application by adding:
				<programlisting language="kermeta">
import "${fsm_model.baseUri}/model/fsm.ecore" using EMFBytecode(fsm_model)
				</programlisting>
				</para>
				
				<para>
				Now right clic on your project.kp -> clean and build. Then in the target folder open "beforeCheckingforScopeRESOLVED.km". This is the final model generated by the Kermeta 2 compiler. It is a reflect of the assemblage defined in the "project.kp".
				You can see two metamodels: kermeta and your own. Open yours to see the FSM model was successfully imported. 
				</para>
			</section>
			<section id="Implementation">
				<title>Write aspects on the classes</title>
				
				<para>Right clic on your project New -> Other -> Kermeta -> Kermeta File.</para>
				
				<mediaobject>
					<imageobject>
						<imagedata
							fileref="Kermeta-FSMDslTutorial_figures/24_create_new_kermeta_file.png"
							format="PNG" />
					</imageobject>
				</mediaobject>
				
				<para>Rename it "fsm_Operationnal_Semantics.kmt".</para>
				
				<mediaobject>
					<imageobject>
						<imagedata
							fileref="Kermeta-FSMDslTutorial_figures/25_name_new_kermeta_file.png"
							format="PNG" />
					</imageobject>
				</mediaobject>
				
				<para>And add it in the "project.kp":</para>
				
				<programlisting language="kermeta">
import "${project.baseUri}/src/main/kmt/fsm_Operationnal_Semantics.kmt"
				</programlisting>
				
				<para>Then you can write aspect on the metaclasses to add the behavior:</para>
				
				<programlisting language="kermeta">
using fsm::*
using kermeta::standard::*
using kermeta::io::StdIO => stdio
using kermeta::persistence::*
using kermeta::exceptions::*

package fsm{

	aspect class FSM 
	{
	
	//attribute ownedState : oset State[0..*]#owningFSM
		//reference initialState : Transition[1..*] 
		//reference finalState : State[0..*]
		reference currentState : State

		  
		// Operational semantic
		operation run() :  Void is do  
			// reset if there is no current state
			if self.currentState == void then self.currentState := self.initialState end
			self
			from var str : String init "init"
			until str == "quit"
			loop
				stdio.writeln("Current state : " + self.currentState.name)
				str := stdio.read("give me a letter : ")
				if str == "quit" then
					stdio.writeln("")
					stdio.writeln("quitting ...")
				else 
					if str == "print" then
						stdio.writeln("")
					else	
						stdio.writeln(str)			
						stdio.writeln("stepping...")
						do
							var textRes : String
							textRes := self.currentState.step(str)
							if( textRes == void or textRes == "" )
							then
								textRes := "NC"
							end
							
							stdio.writeln("string produced : " + textRes)
						
							rescue (err : ConstraintViolatedPre)
			            		stdio.writeln(err.toString)
			            		stdio.writeln(err.message)
			            		str := "quit"
			            	rescue (err : ConstraintViolatedPost)
		            			stdio.writeln(err.toString)
		            			stdio.writeln(err.message)
		            			str := "quit"
		            		
							rescue(err : NonDeterminism)
								stdio.writeln(err.toString)
								str := "quit"	
							rescue(err : NoTransition)
								stdio.writeln(err.toString)
								str := "quit"
		            	end
					end
				end
			end
		end
		
		/** Initialize a new automaton from an existing one 
		 *  param :
		 *    p_state : the initial state
		 *    isInitComb
		 */
		operation initialize(p_state : State, isInitComb : Boolean) is do
			var initState : State init p_state.copy
			ownedState.add(initState)
			initialState := initState 
			if (isInitComb == true) then initialState.combination := Set&lt;State&gt;.new end 
		end
		
	}
	
	aspect class State {
		
			reference combination : Set&lt;State&gt;
		
	
		// Go to the next state
		operation step(c : String) : String
		is do
			// Get the valid transitions
			var validTransitions : Collection&lt;Transition&gt; 
			validTransitions :=	outgoingTransition.select { t | t.input.equals(c) }
			// Check if there is one and only one valid transition
			if validTransitions.empty then raise NoTransition.new end
			if validTransitions.size > 1 then raise NonDeterminism.new end
			
			// Fire the transition
			result := validTransitions.one.fire
		end
		
		// Create a new state from self state
		operation copy() : State is do
			result := State.new
			result.name := ""+name //clone
			result.combination := Set&lt;State&gt;.new
		end
	}
	
	aspect class Transition 
	{	
		
		// Fire the transition
		operation fire() : String is do
			// update FSM current state
			source.owningFSM.currentState := target
			result := output
		end
	}
	
	abstract class FSMException inherits Exception{}
	class NonDeterminism inherits FSMException {}
	class NoTransition inherits FSMException {}
	class NoInitialStateException inherits FSMException{}

}
				</programlisting>
				
			</section>
			<section id="Write the simulation">
				<title>Write the simulation</title>
				<para>
				Add another Kermeta File in your project and name it "fsmLauncher.kmt". Don't forget the "project.kp":
				<programlisting language="kermeta">
import "${project.baseUri}/src/main/kmt/fsmLauncher.kmt"
				</programlisting>
				This file will contains the simulator, which will call operations from your aspects.
				As an entry point of your program it contains also the main method ( fix your "project.kp" if needed ) and a method to load an instance model of your metamodel.
				<programlisting language="kermeta">
using fsm::*
using kermeta::standard::*
using kermeta::io::StdIO => stdio
using kermeta::emfpersistence::*
using kermeta::exceptions::*

package fsm{
	
	class Main
	{
		@main ""
		operation mainloadFSM(input_automaton : String) : Void is do
			var theFSM : FSM init loadfsm(input_automaton)
			printFSM(theFSM)
			theFSM.run()
		end
		
		 /*
		 * Load the FSM model from the xmi file sample1.fsm
		 * It's an instance of the FSM metamodel
		 * "../models/sample1.fsm"
		 */
		operation loadfsm(input_automaton : String) : FSM is do
			var rep : ResourceSet init ResourceSet.new
			result := AutomatonHelper.new.loadEMFAutomaton(rep, input_automaton, "http://www.kermeta.org/fsm")
	        
	        // Uncomment to check the invariant properties : WFR
	        // To check all contained elements by "result"
	        //result.checkAllInvariants
	        // To check only the states that are contained in "result"
	        //checkWFR(result)
		end

		/**
		 * For all states, we check the Well-Formedness rules
		 */
		operation checkWFR(theFSM : FSM) is do
			stdio.writeln("Check WFR : start")
			theFSM.ownedState.each{ s | 
				do
					// Call the invariant verification
					s.checkInvariants
					rescue (err : ConstraintViolatedInv)
			            stdio.writeln(err.toString)
			            stdio.write(err.message)
			            stdio.writeln(" on " + s.name)
			    end
			}
			stdio.writeln("Check WFR : end")
		end
		
		
		/**
		 * Print the FSM on the standard output
		 */
		operation printFSM(fsm : FSM) is do
			fsm.ownedState.each 
			{ s | 
				stdio.writeln("State : " + s.name)
				s.outgoingTransition.each { t | 
					var outputText : String
					if( t.output != void and t.output != "" )
						then outputText := t.output
						else outputText := "NC"
					end
					stdio.writeln("  Transition : " + t.source.name + "-(" + t.input + "/" + outputText + ")->" + t.target.name)
				}
			}
		end
	
	}
}
				</programlisting>
				
				<section>
					<title>Load/Save models</title>
					<para>
					AutomatonHelper is an object defined in "fsm_Helper.kmt" from the "org.kermeta.language.sample.fsm.simulation" project. It provide useful operations like save  and load model.
					</para>
					<para>
					In Kermeta 2, models import/export are managed by Resources object, which need URI of the model and metamodel both.
					<programlisting language="kermeta">
var resource : Resource init repository.createResource(model_uri , metamodel_uri)
					</programlisting>
					Then you can use load method to get a model:
					<programlisting language="kermeta">
resource.load(void)
					</programlisting>
					Or use the save method:
					<programlisting language="kermeta">
resource.save(void)
					</programlisting>
					</para>
				</section>

				</para>
			</section>
			<section id="Run the simulation">
				<title>Run the simulation</title>
				<para>
				TODO: config the eclipse launcher
				</para>
				<para>
				In this example we execute a step into the fsm behaviour algorithm with the file samplerun.fsm stored into org.kermeta.language.sample.fsm.model/models/samplerun.fsm.
				You use the transition c to go to s1 to s2 and produce the string v. The behaviour can be produced thanks to the operations run(), step() and fire() defined in the last section.
				</para>
				<para>Do a right clic on the "project.kp" of your simulation and in "Run As" select "Run Configurations...". Create a new "Kermeta Application" launcher. Fields are automatically filled but you have to set "Operation arguments". Indeed your main operation need the location of your model (the "samplerun.fsm" so).</para>
				<para>You should obtain the following trace : </para>
				<mediaobject>
					<imageobject>
						<imagedata
							fileref="Kermeta-FSMDslTutorial_figures/result_example_behaviour.png"
							format="PNG" />
					</imageobject>
				</mediaobject>
				
			</section>
		</section>
	</chapter>
	
	<chapter>
		<title>Model transformation</title>
		<para>  
		The projects Minimization and Determinization are examples of transformations of one model to one another,let you have a look on it.
		</para> 
		<para>
		These examples are separated into three main steps :
		<itemizedlist>
			<listitem>load the model to transform and initialize the output model</listitem>
			<listitem>traitment of the transformation (use an algoritm to determin the new results and add it into other output model)</listitem>
			<listitem>save the output model</listitem>
		</itemizedlist>
    	</para>
    	
		<section id="determinization">
			<title>Determinization</title>
			<para>In your FSM you can have states where two (or more) outgoing transitions have the same input. 
				This implies the machine have to determine which way to go. 
				That why we use an algorithm on to FSM to remove choices. 
				In other words, we tranform our model to another model, which will be determinist.</para>
			<section>
				<title>Algorithm</title>
				<para>TODO</para>
			</section>
			<section>
				<title>Implementation</title>
				<itemizedlist>
					<listitem>Create an new Kermeta Project</listitem>
					<listitem>
					Rename MainClass.kmt to Determinization.kmt
					<programlisting language="kermeta">
using fsm::*
using kermeta::standard::*
using kermeta::emfpersistence::*

package fsm{
	 
	class Determinization 
	{ 
		reference processed_states : &lt;SetState&gt;
		reference repository : ResourceSet
		reference helper : AutomatonHelper
		
		@main ""
	    operation main(input_automaton : String) : Void is do 
	    
	    	// Input automaton (non-determinist)
	    	var input : FSM
			var output : FSM init FSM.new
			var output_path : String
			// Initialize attributes
			processed_states := Set&lt;State&gt;.new
			repository := ResourceSet.new
			helper := AutomatonHelper.new 
			 
			// The input automaton to determinize
			input :=  helper.loadEMFAutomaton(repository, input_automaton, "http://www.kermeta.org/fsm")
			
			output_path := input_automaton.substring(0, input_automaton.size-3)+"det.fsm"
	
		   	output.initialize(input.initialState, true)
	
	    	determinize(input, output, output.initialState)
	
		    // Define the final states : q' intersection initial Final states is void
		    output.finalState.addAll
		    ( 
				AutomatonHelper.new.seqToSet( output.ownedState.select { 
			e | e.combination.detect{ a | 
			    input.finalState.contains(a) } != void  } )
			)
			
	    	// We don't need combination to be stored
	    	output.ownedState.each { e | e.combination.clear } 
	    	helper.dotprint(output)
	    	// Save the automaton
	    	helper.saveEMFAutomaton(ResourceSet.new, output, output_path, "http://www.kermeta.org/fsm")
	
	    end
	    
	    operation determinize(input : FSM, output : FSM, output_state : State) is do
	    
	    	if not processed_states.contains(output_state) then
	   			processed_states.add(output_state)
		    	// For each letter of the alphabet
		    	input.alphabet.each { nextl |
	    			// There exists a state x of q' (where q' is a P(Q))
	    			// and state-y from Q so that : x --l-->  y belongs to input.transitionSet
			    	var newq : State init State.new
					newq.combination := helper.seqToSet(
	    				input.ownedTransition.select { e | e.input.equals(nextl) }.
	    				select { a | 
	    					output_state.name == a.source.name
	    					or
	    					output_state.combination.detect { i | 
	    						i.name==a.source.name } != void }.collect { b | 
	    							b.target }  
	    				)
	    				
	    			newq.name := join(newq.combination.collect{ a | a.name })
	
	    			// Add the state to the output automaton if we found one
	    			if (newq.name.size > 0) then  
						// Add the new state
						if (output.ownedState.detect { e | newq.name == e.name } == void) then  
							output.ownedState.add(newq)
						else
							newq := output.ownedState.detect { e | e.name == newq.name }
						end
						// Add the new transition
						var newt : Transition init helper.createTransition(output_state, newq, nextl)  
						output.ownedTransition.add(newt)
						self.determinize(input, output, newq)
		    		end
				}	// End of Loop
	    	end  
	    end
	   
	    operation join( str_seq : Collection&lt;String&gt;) : String is do
	    	result := ""
			from var it : Iterator&lt;String&gt; init str_seq.iterator
			until it.isOff
			loop
				result.append(it.next)
			end
	    end
	    
	}
}
/*
Algorithme: we begin with a non deterministic automaton.
We build the deterministic automaton which has:

   1. states: the parts of Q
   2. initial state: the I state
   3. transitions: (U,a,V) where V is the set of reachable states from U through a transition 'a'
   4. terminal states: states which combination contains the final state of initial automaton
   */
					</programlisting>
					</listitem>
					<listitem>
					Change the project.kp
					<programlisting language="kermeta">
resource library_standard ="platform:/plugin/org.kermeta.language.library.standard" alternative "mvn:org.kermeta.language/org.kermeta.language.library.standard/2.0.99-SNAPSHOT"
resource fsm_model = "platform:/resource/org.kermeta.language.sample.fsm.simulation"

importProject library_standard

project org_kermeta_language_sample_fsm_determinization extends fsm_model{

	mainClass "org_kermeta_language_sample_fsm_determinization^fsm::Determinization"
	mainOperation "main"

	import "${project.baseUri}/src/main/kmt/determinization.kmt"
	
}
					</programlisting>
					</listitem>
				</itemizedlist> 
			</section>
		</section>
		<section id="minimization">
			<title>Minimization</title>
			<para>In some case a FSM have redundant parts. So we can use a transformation of model to remove duplicated states and reduce the size of the graph.</para>
			<section>
				<title>Algorithm</title>
				<para>TODO</para>
			</section>
			<section>
				<title>Implementation</title>
				<itemizedlist>
					<listitem>Create an new Kermeta Project</listitem>
					<listitem>
					Rename MainClass.kmt to Minimization.kmt
					<programlisting language="kermeta">
using fsm::*
using kermeta::standard::*
using kermeta::io::StdIO => stdio
//using kermeta::persistence

package fsm{
	
	
	
	class Minimization
	{
		reference equivalent_pairs : set Pair[0..*]  // The initial pairSet of the equivalence relation { F \ Q }ï¿½ ^ Fï¿½
		reference all_input_pairs : set Pair[0..*]       // The QxQ set of possible pairs, where Q is the stateSet
		reference helper : AutomatonHelper
		
		@main ""
	    operation main() : Void is do 
	    
	    	// Input automaton (non-determinist)
	    	var input : FSM
			var output_path : String
			var output : FSM init FSM.new
			
			// Initialize attributes
		   	helper := AutomatonHelper.new 
			//input := Sampler.new.createSampleM1() // "../models/sampleM1min.automaton"
			
			input := helper.ask_emfmodel("Enter the EMF model of the automaton to minimize: ")
			output_path := stdio.read("Enter the output file where to store the minimal automaton:\nplatform:/resource/org.kermeta.language.sample.fsm.model/models/") 
			output_path := "platform:/resource/org.kermeta.language.sample.fsm.model/models/"+output_path
			
			stdio.writeln("input:"+ input.isVoid.toString + "tostring : "+ input.toString)
	
		   	// Initialize equivalent_pairs and possible all_input_pairs
		   	input.ownedState.each { p | input.ownedState.each { b | 
		   		// Check : (p,q) is in Eo, i.e either both are final states or both are NOT final states
		   		var isFinalLeft : Boolean init input.finalState.detect { e | p.name == e.name }!=void
		   		var isFinalB    : Boolean init input.finalState.detect { e | b.name == e.name }!=void
		   		// Also fill the all input pairs
		   		if find_one(all_input_pairs, p, b) == void then all_input_pairs.add(helper.createPair(p, b)) end
		   		if  ((isFinalLeft and isFinalB) or (not isFinalLeft and not isFinalB)) 
			      and
				      find_one(equivalent_pairs, p, b) == void
			    then 
			    	stdio.writeln("{"+p.name + ","+b.name+"} ,")
			   		equivalent_pairs.add(helper.createPair(p, b))
		   	    end
		   	    } } 
			stdio.writeln("Eo = Square{F-Q}^Square{F} is initialized")	   	     
		   	// Minimalize 
	    	minimalize(input, output)
	    	
	    	//output.prettyprint
	    	// We do not want to store combination
	    	output.ownedState.each { s | s.combination.clear } 
			helper.dotprint(output)
			helper.saveEMFAutomaton(kermeta::emfpersistence::ResourceSet.new, output, output_path, "http://www.kermeta.org/fsm")
	    end
	
	
	    /**
	     * MINIMIZATION ALGORITHM
	     * params : 
	     *    - input : the non-minimalized automaton
	     *    - output : the minimal automaton equivalent to input
	     */
	    operation minimalize(input : FSM, output : FSM) is do
	    	// Remove not accessible states
	    	remove_unavailable_states(input)
	    	// final_equivalent_pairs : the smallest equivalent pair set
			var final_equivalent_pairs : Set&lt;Pair&gt; init Set&lt;Pair&gt;.new
			final_equivalent_pairs.addAll(equivalent_pairs)
			var old_equivalent_pairs : Set&lt;Pair&gt; init all_input_pairs
	    	from var it : Iterator&lt;Pair&gt; init old_equivalent_pairs.iterator
	    	until old_equivalent_pairs == final_equivalent_pairs
	    	loop
	    		old_equivalent_pairs := final_equivalent_pairs
	    		// For each pair
	    		old_equivalent_pairs.each { eqPair |
	    			// For all letters of input, if eqPair is not valid, remove it
		    		if (isNotOwnedTransition(input, eqPair, old_equivalent_pairs) == true) then 
		    			// remove this pair from final eq. pairs (H)
		    			final_equivalent_pairs := old_equivalent_pairs
		    			var fp : Pair init find_one(final_equivalent_pairs, eqPair.left, eqPair.right)
		    			if (fp!=void) then
		    				if (fp.left.name!=fp.right.name) then // the twin pairs are always valid!
			    				final_equivalent_pairs.remove(fp)
			    			end 
		    			end
		    		end
	    		}
	    	end
	    	stdio.writeln("Minimalize succeeded")
	    	// Create the equivalent classes, which become the new states
	    	createEquivalenceClasses(output, input.ownedState, old_equivalent_pairs)
	    	stdio.writeln("Equivalence classes creation succeeded : " + output.ownedState.size.toString)
			output.ownedState.each { s | s.name := helper.join(s.combination.collect{ a | a.name })  }
			// Create the transition between the new states -- inputStates contains the links to their eq.class
	    	createEquivalentTransitions(output.ownedState, input.ownedState, input.ownedTransition)
	    	stdio.writeln("Transition set creation succeeded")
	    	// Set the initial and the final states
	    	output.initialState := input.initialState.combination.one
	    	output.finalState.addAll(input.finalState.one.combination) 
	    end     
	               
	    /** Find the pair in pairSet which equals (left, right) or (right, left) (xRy => yRx) */
	    operation find_one(pairSet : Set&lt;Pair&gt;, left : State, right : State) : Pair is do
	    	result := pairSet.detect { p | 
	   		(p.left.name == left.name and p.right.name == right.name) or
	   		(p.right.name == left.name and p.left.name == right.name) }
	    end
	    
	    /** Remove the states to which no transition leads */
	    operation remove_unavailable_states(a : FSM) is do
	    
	    var tmpState : State init State.new
	    
			var as_seq : Sequence&lt;State&gt; init a.ownedState.reject { s | not a.ownedTransition.collect { t | t.target}.contains(s) and s != a.initialState}
			var at_seq : Sequence&lt;Transition&gt; init a.ownedTransition.reject { t | not as_seq.contains(t.target) }
			a.ownedTransition.clear
			a.ownedTransition.addAll(at_seq)
			a.ownedState.clear
			a.ownedState.addAll(as_seq)
	    end
	         
	    /** 
	     *  If the result state-pair ( T(pair.left), T(pair.right) ) does not belong to equivalent pairs then
	     *  return true otherwise false
	     *  params : 
	     *    - automaton : the automaton in which we test the validity of the result state-pair
	     *    - pair : the pair on which we apply each transition of automaton
	     *    - equivalent_pairs : the equivalent_pairs in which we search the result state-pair
	     */
	    operation isNotOwnedTransition(automaton : FSM, pair : Pair, equivalent_pairs : Set&lt;Pair&gt;) : Boolean is do 
	    	//  if there exists a letter a in the automaton such as T(pair.left, a), T(pair.right, a) belongs to distinct_pairs
	    	//  "void" pair is allowed!
	    	result := false
	    	from var it : Iterator&lt;String&gt; init automaton.alphabet.iterator
	    	until it.isOff or result == true
	    	loop
	    		var letter : String init it.next
	    		var tleft : Transition init automaton.ownedTransition.detect { t | t.source.name==pair.left.name and t.input == letter }
	    		var tright : Transition init automaton.ownedTransition.detect { t | t.source.name==pair.right.name and t.input == letter }    		
	    		if (tleft!=void and tright!=void) then // empty word belongs to accepted words
	    			if find_one(equivalent_pairs, tleft.target, tright.target) == void then
		    			result := true	    		
		    		end
		    	else if (tleft==void and tright!=void) or (tleft!=void and tright==void) then result:=true end
		    	end
	    	end
	    end
	    
	    /**
	     * Principle of the creation of the equivalent classes :
	     *     for each state of the initial automaton do :
	     *           select all the pairs which first element is this state
	     *                for each of these pairs, if right element is not "classed" yet, do :
	     *                    * if a class does not exist for the left element, create one
	     *                    * add the right element to the class of the left one
	     *                end
	     *     end
	     */
	    operation createEquivalenceClasses(output : FSM, stateSet : Set&lt;State&gt;, equivalent_pairs : Set&lt;Pair&gt;) is do
	    	var eqClass : Set&lt;State&gt; init Set&lt;State&gt;.new
	    	from var it : Iterator&lt;State&gt; init stateSet.iterator
	    	until it.isOff
	    	loop
	    		var state : State init it.next
	    		var news : State init State.new// eqClass as new state of output
		    	equivalent_pairs.select
		    	{ pair | pair.left.name == state.name }.each
		    	{ pair |
		    		// combination becomes an improvised "marker"
		    		// if it is void, it means that it does not belong to a eqclass yet
	    			if (state.combination == void) then 
	    				// create the eq. class and the state
		    			news.combination := Set&lt;State&gt;.new
		    			news.combination.add(pair.left)
		    			output.ownedState.add(news)
		    			// Mark state that is already added // we use combination to ease the transition computation
		    			state.combination := Set&lt;State&gt;.new 
		    			state.combination.add(news)
		    		end
		    		// Process the right element of the pair : add it to the eq.class of the left element!
		    		var sright : State init stateSet.detect { s | pair.right.name == s.name and s.combination == void }
	    			if (sright != void) then
	    				// Complete the eq. class
	    				var found_eq : State init output.ownedState.detect{ c | c.combination.detect{ s| s.name==state.name }!=void }
	    				found_eq.combination.add(pair.right) 
	    				if (sright.combination == void) then
		    				sright.combination := Set&lt;State&gt;.new 
		    				sright.combination.add(found_eq)
		    			end
	    			end
	    		}
	    	end
	    end
	    
	    /** 
	     * Create the transitions of the minimal automaton
	     * params :
	     *     - eqClassStateSet : the minimal automaton set of states
	     *     - ownedState : the input automaton set of states
	     *     - ownedTransition : the intput automaton set of transitions
	     */
	    operation createEquivalentTransitions(
	    	eqClassStateSet : OrderedSet&lt;State&gt;, ownedState : OrderedSet&lt;State&gt;, ownedTransition : OrderedSet&lt;Transition&gt;) : Void is do
	    	var aResult : OrderedSet&lt;Transition&gt; init OrderedSet&lt;Transition&gt;.new
	    	
	    	// for each eq-class
	    	ownedState.each { nextInputState |
	    		
	    		// Get the eq.class to which the current state belongs
	    		var nextEqClassState : State init nextInputState.combination.one 
	    		
				// For each letter, Get the transition for which the current state is a source
				var nextTransitionSet : Sequence&lt;Transition&gt; init ownedTransition.select { t | t.source == nextInputState }
				
				// The target combination is the eq. class target of the new transition!
				nextTransitionSet.each { t |
					// Add this transition
					if aResult.detect {  rt | rt.source == nextEqClassState and rt.input == t.input } == void then
						var nextEqClassStateTarget : State init eqClassStateSet.detect { s | s.combination.detect{ cs | cs.name==t.target.name }!=void }
						var newTransition : Transition init helper.createTransition(nextEqClassState, nextEqClassStateTarget, t.input)
						aResult.add(newTransition)
					end
				}
	    	}
	    end
	    
	}
}
					</programlisting>
					</listitem>
					<listitem>
					Change the project.kp
					<programlisting language="kermeta">
resource library_standard ="platform:/plugin/org.kermeta.language.library.standard" alternative "mvn:org.kermeta.language/org.kermeta.language.library.standard/2.0.99-SNAPSHOT"
resource fsm_model = "platform:/resource/org.kermeta.language.sample.fsm.simulation"//"mvn:org.kermeta.language.sample.fsm/org.kermeta.language.sample.fsm.simulation/2.0.99-SNAPSHOT"

importProject library_standard
//importProject fsm_model

project org_kermeta_language_sample_fsm_minimization extends fsm_model{

	mainClass "org_kermeta_language_sample_fsm_minimization^fsm::Minimization"
	mainOperation "main"

	import "${project.baseUri}/src/main/kmt/minimization.kmt"

}
					</programlisting>
					</listitem>
				</itemizedlist> 
			</section>
		</section>
	</chapter>
	
	<chapter>
		<title>Overview</title>
		<para>TODO: this is the result of the tuto</para>
		<section>
			<title>What you get at the end</title>
			<itemizedlist>
				<listitem>A metamodel of FSM</listitem>
				<listitem>An model editor</listitem>
				<listitem>A FSM simulator</listitem>
				<listitem>Two model transformations</listitem>
			</itemizedlist> 
		</section>
		<section>
			<title>Getting the solution: the FSM sample</title>
			<para>Kermeta 2 provides a set of examples to show his skills. Among them you can retrieve the FSM sample, which will install Kermeta 2 projects in your workspace. You will find into them, as a support of this tutorial, the working source code. To do this just go in File -> New -> Example and then select "Kermeta 2 FSM sample" in "Kermeta 2 samples"</para>
		</section>
		<section>
			<title>Test cases</title>
			<para>TODO</para>
			 <table frame="all"><title>Provided models in the "model" folder and their uses</title>
				 <tgroup cols="3" align="left" colsep="1" rowsep="1">
					 <thead>
					 <row>
					   <entry>Input FSM Model</entry>
					   <entry>Motivation</entry>
					   <entry>Kermeta Run Configuration Uses</entry>
					 </row>
					 </thead>
					 <tbody>
						<row>
						    <entry>complextodet.fsm</entry>   
						    <entry>a FSM model with a lot of states and transitions for testing and improving the determinization algorithm</entry>
						    <entry> fsm.demo.determinization (not by default)
									fsm.demo.checkInvariants (not by default)</entry>
						</row>  
						<row>
						    <entry>exampledemo.fsm</entry>   
						    <entry>a very simple example with 2 states and non-deterministic transitions => checkInvariant returns "the invariant will be violated"</entry>
						    <entry>fsm.demo.checkInvariants (not by default)</entry>
						</row> 
						<row>
						    <entry>helloWorld.fsm</entry>   
						    <entry>an example for printing "Helloworld!"</entry>
						    <entry>fsm.demo.loaderFsm (not by default)</entry>
						</row> 
						<row>
						    <entry>sample1.fsm</entry>   
						    <entry>that is the nominal test case: a very simple example with 2 states and with deterministic transitions => "none invariant will be violated"</entry>
						    <entry>	fsm.demo.checkInvariants (by default)
 									fsm.demo.loaderFsm (by default)</entry>
						</row> 
						<row>
						    <entry>sample1postv.fsm</entry>   
						    <entry>an example with 2 states and with deterministic transitions, but the first transition has not output parameter, thus the post condition will be violated</entry>
						    <entry>fsm.demo.loaderFsm4prepost (by default)</entry>
						</row> 
						<row>
						    <entry>samplerun.fsm</entry>   
						    <entry>an example with 2 states and deterministic transitions</entry>
						    <entry>fsm.demo.loaderFsm (not by default)</entry>
						</row> 
						<row>
						    <entry>sampletodeterminize.fsm</entry>   
						    <entry>an example with 2 states and non-deterministic transitions</entry>
						    <entry>fsm.demo.determinization (by default)</entry>
						</row> 
					 </tbody>
				</tgroup>
			</table>
			Note:
			<itemizedlist>
				<listitem>"not by default" means that you must adapt arguments in the given "Kermeta Run Configuration".</listitem>
				<listitem>*.fsmdi are the graphical view of FSM models.</listitem>
			</itemizedlist> 
		</section>
	</chapter>

</book>
			