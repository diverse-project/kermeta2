<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<!-- $Id$ -->
<book lang="en-US">
	<bookinfo>
		<mediaobject>
			<imageobject>
				<imagedata fileref="Kermeta-Manual_figures/KermetaLogo.png"
					format="PNG" />
			</imageobject>
		</mediaobject>
		<title>Use case of Kermeta 2</title>
		<subtitle>Finite state machine sample</subtitle>

		<pubdate>Build
			: &version; &buildNumber;
		</pubdate>
		<date>$Date:: $</date>
		
		<author>
			<firstname>Fabien</firstname>
			<surname>Coulon</surname>
		</author>

		<keywordset>
			<keyword>Kermeta</keyword>
			<keyword>metamodeling</keyword>
			<keyword>language</keyword>
			<keyword>dsl</keyword>
			<keyword>FSM</keyword>
			<keyword>sample</keyword>
		</keywordset>

		<abstract>
			<para>In this tutorial we will show how Kermeta 2 can help you to add sematic on your own model, how to transform it to another model and how to build a basic interpreter.</para>
		</abstract>

		<publisher>
			<publishername>INRIA</publishername>

			<address>
				<state>France</state>
				<otheraddr>
					<ulink url="http://www.inria.fr">http://www.inria.fr</ulink>
				</otheraddr>
			</address>
		</publisher>
	</bookinfo>

	<preface id="preface.link">
		<title id="preface.title.link">
			Presentation
			<phrase id="preface"></phrase>
		</title>
		<para>Kermeta action language is a DSL designed to manipulate
			models. However it
			isn't a general purpose language and thus doesn't
			directly offer all
			the libraries to build for example an application 
			with a
			sophisticated GUI.
		</para>

		<important>
			<title>Prerequisite</title>
			<para>Preconditions so that the tutorials could run correctly</para>
			<itemizedlist>
				<listitem>
					<para>Use an Eclipse Modeling Tools based on a Juno version</para>
				</listitem>
				<listitem>
					<para>On Eclipse IDE should be installed Kermeta language plug-in
						based upon a Release version
					</para>
				</listitem>
				<listitem>
					<para>On Eclipse IDE should be installed Maven plug-in</para>
				</listitem>
				<listitem>
					<para>Eclipse must be started using a JDK (not a JRE). This must be
						specified in the eclipse.ini file using the -vm option.
					</para>
				</listitem>
			</itemizedlist>
			<para>Alternatively to the first 3 points, you can use the predefined
				eclipse package with all kermeta tools preinstalled.
			</para>
		</important>
		<important>
			<para>This tutorial serie explain various procedure to acheive some
				goal, however, the attentive reader must know that even if the
				presented procedure work, you may acheive similar results using
				alternative or slightly modifying the proposed procedure because you
				ma decide to use another tool or use it differently. Roughly,
				all
				this tutorial serie is actually about :
			</para>
			<itemizedlist>
				<listitem>
					<para>Java compilation, and the support of java compatible language
						like Scala and groovy. (special care to the compilation classpath)
					</para>
				</listitem>
				<listitem>
					<para>OSGI/Eclipse packaging and deployment, which requires to take
						care to the jar content and to the runtime classpath (which can be
						different from the compilation classpath !)
					</para>
				</listitem>
			</itemizedlist>
			<para>In all cases, there are various ways to compile, package and
				deploy, either using Eclipse builders or using maven.
			</para>
			<para>This tutorial will try to give suggestions and explain the
				underlying process but explaining maven, Eclipse, java, OSGI isn't
				in the scope of this document. The user must be ready to find and
				read the appropriate documentations.
			</para>
		</important>
	</preface>
	
	<chapter>
		<title>Introduction</title>
		To illustrate the use of Kermeta 2, we will study the case of a Finite state machine(FSM).
		At the end of this tutorial you will know how to use Kermeta 2 for :
		<para> 
			<itemizedlist>
				<listitem>
					<para>Import a model in Kermeta 2</para>
				</listitem>
				<listitem>
					<para>Adding constaints on your model</para>
				</listitem>
				<listitem>
					<para>Browsing your model</para>
				</listitem>
				<listitem>
					<para>Adding behavior on your model</para>
				</listitem>
				<listitem>
					<para>Make a running application based on your model</para>
				</listitem>
			</itemizedlist>
		</para>
	</chapter>
	
	<chapter>
		<title>Define the FSM metamodel</title>
		<para> An I/O state machine  is composed with two kind of elements: states and transitions which linking them. There is a current state in the machine, which begin on the initial state end finish on the final state. The current state move between states by following transitions. A transition is followed if the input is read. And if transition is followed the ouput is writed</para>
		<para>
			This example recognizes the "hello!" motif and produces the "world!" motif. Here, we present this finite-state machine in a specific graphical syntax where states are squares and transitions are arrows between squares. Input and outputs are present above transitions. Here, "h/w" says that we consume an "h" to produce a "w"
			<mediaobject>
				<imageobject>
					<imagedata
						fileref="Kermeta-FSMDslTutorial_figures/helloWorldFSM.png"
						format="PNG" />
				</imageobject>
			</mediaobject>
		</para>
		<para>
			Because of a good diagram is more efficient than a long description, have a look at this metamodel:
			<mediaobject>
				<imageobject>
					<imagedata
						fileref="Kermeta-FSMDslTutorial_figures/FSMBeginningMM.png"
						format="PNG" />
				</imageobject>
			</mediaobject>
		</para>
	</chapter>
	
	<chapter>
		<title>Models &amp; Metamodel</title>
		<para> In this section we will define, with EMF, the metamodel and make a simple editor to create some conforms models, which will be the input of Kermeta 2. You can do this works with Kermeta but this is not the purpose of this tutorial, here we want show how the 2 technologies work together</para>
		
		<section id="metamodel">
			<title>Creation of the metamodel</title>
			<para>
				The first step is to make the .ecore file, which will describe your metamodel.
				Create a new project in File -> New -> Project and in "Eclipse Modeling Framework" select "Empty EMF Project". 
				<mediaobject>
					<imageobject>
						<imagedata
							fileref="Kermeta-FSMDslTutorial_figures/1_empty_project.png"
							format="PNG" />
					</imageobject>
				</mediaobject>
				Name your project "model".
				<mediaobject>
					<imageobject>
						<imagedata
							fileref="Kermeta-FSMDslTutorial_figures/2_name_empty_project.png"
							format="PNG" />
					</imageobject>
				</mediaobject>
				The project appear now in your workspace.
				<mediaobject>
					<imageobject>
						<imagedata
							fileref="Kermeta-FSMDslTutorial_figures/3_empty_project_created.png"
							format="PNG" />
					</imageobject>
				</mediaobject>
				Then create the .ecore file with a right clic on your project and select New -> Other. Choose "Ecore Model" in "Eclipse Modeling Framework".
				<mediaobject>
					<imageobject>
						<imagedata
							fileref="Kermeta-FSMDslTutorial_figures/4_add_ecore.png"
							format="PNG" />
					</imageobject>
				</mediaobject>
				Name your file fsm.ecore and put it in the "model" folder of your project.
				<mediaobject>
					<imageobject>
						<imagedata
							fileref="Kermeta-FSMDslTutorial_figures/5_name_ecore.png"
							format="PNG" />
					</imageobject>
				</mediaobject>
				Select "EPackage" and clic on finish.
				<mediaobject>
					<imageobject>
						<imagedata
							fileref="Kermeta-FSMDslTutorial_figures/6_type_ecore.png"
							format="PNG" />
					</imageobject>
				</mediaobject>
				Your .ecore is created, we must fill it now !
				<mediaobject>
					<imageobject>
						<imagedata
							fileref="Kermeta-FSMDslTutorial_figures/7_project_with_ecore.png"
							format="PNG" />
					</imageobject>
				</mediaobject>
				Open fsm.ecore with the "Sample Ecore Model Editor". It is the default Eclipse editor for .ecore file.
				Then do a right clic on the fsm package in the model and in "New Child" select "EClass" to create the three mains elements of our model: FSM, State and Transition.
				<mediaobject>
					<imageobject>
						<imagedata
							fileref="Kermeta-FSMDslTutorial_figures/8_ecore_classes.png"
							format="PNG" />
					</imageobject>
				</mediaobject>
				We will creates attributes and references for the State. Reference types are related to EClass whereas EAttributes are simple types.
				Right clic on State, New Child and clic on EAttribute. 
				Open the Properties view in "Window" -> "Show view" -> "Other" and "Properties" in "General" folder. This view is useful to edit attributes of model elements. Set "name" as Name of the EAttibute created.
				Create three other EReference for the State and name them "outgoingTransition", "incomingTransition" and "owningFSM". You can change the cardinality with "Lower" and "Upper Bound", where -1 means infinity. 
				Set the EType for each one. We will also set EOpposite values after we have defined attributes of others Classes.
				I let you to finish yourself the fsm.ecore according to the "Define the FSM metamodel" section. ;)
				You can get the solution in the subsection "Getting the solution: the FSM sample" of the last chapter of this tutorial.
				<mediaobject>
					<imageobject>
						<imagedata
							fileref="Kermeta-FSMDslTutorial_figures/9_ecore_attributes.png"
							format="PNG" />
					</imageobject>
				</mediaobject>
				Now we suppose your fsm.ecore looks like mine in the screenshot.
				<mediaobject>
					<imageobject>
						<imagedata
							fileref="Kermeta-FSMDslTutorial_figures/10_ecore_full.png"
							format="PNG" />
					</imageobject>
				</mediaobject>
			</para>
		</section>
		<section id="genmodel">
			<title>Creation of the editor</title>
			<para>
				We will now create the .genmodel file. This is a code generator based on an .ecore file. To be simple: it creates a Java implementation of your metamodel and can generate a simple editor with creating instance of your metamodel.
				Right clic on your project and select New -> Other, and "EMF Generator Model" in "Eclipse Modeling Framework".
				<mediaobject>
					<imageobject>
						<imagedata
							fileref="Kermeta-FSMDslTutorial_figures/11_create_genmodel.png"
							format="PNG" />
					</imageobject>
				</mediaobject>
				Name it "fsm.genmodel".
				<mediaobject>
					<imageobject>
						<imagedata
							fileref="Kermeta-FSMDslTutorial_figures/12_name_genmodel.png"
							format="PNG" />
					</imageobject>
				</mediaobject>
				Base on Ecore model.
				<mediaobject>
					<imageobject>
						<imagedata
							fileref="Kermeta-FSMDslTutorial_figures/13_type_import_genmodel.png"
							format="PNG" />
					</imageobject>
				</mediaobject>
				Select "fsm.ecore" from your workspace.
				<mediaobject>
					<imageobject>
						<imagedata
							fileref="Kermeta-FSMDslTutorial_figures/14_import_ecore_genmodel.png"
							format="PNG" />
					</imageobject>
				</mediaobject>
				Then clic on Finish.
				<mediaobject>
					<imageobject>
						<imagedata
							fileref="Kermeta-FSMDslTutorial_figures/15_package_genmodel.png"
							format="PNG" />
					</imageobject>
				</mediaobject>
				Once you have the genmodel, in the Properties view go to Edit section of "ownedState" of FSM to allow creation of Children in the editor.
				Do the same operation for "outgoingTransition" of State.
				<mediaobject>
					<imageobject>
						<imagedata
							fileref="Kermeta-FSMDslTutorial_figures/16_edit_genmodel.png"
							format="PNG" />
					</imageobject>
				</mediaobject>
				Right clic on the root node of the genmodel and select Generate All. This will generate Java classes implementation of the .ecore in the "src" folder of your project.
				The two projects generated "model.edit" and "model.editor" will be used as Eclipse plugin and are the implementation of your model editor.
				<mediaobject>
					<imageobject>
						<imagedata
							fileref="Kermeta-FSMDslTutorial_figures/17_generate_all_genmodel.png"
							format="PNG" />
					</imageobject>
				</mediaobject>
				Right clic on "model.editor" and Run as -> Eclipse Application. 
				Create a new empty project in your new instance of Eclipse (where your editor is running as a pluging).
				Then go to File -> New -> Other -> Example EMF Model Creation Wizard and select Fsm Model.
				<mediaobject>
					<imageobject>
						<imagedata
							fileref="Kermeta-FSMDslTutorial_figures/18_create_model_editor.png"
							format="PNG" />
					</imageobject>
				</mediaobject>
				Give a name to your model. (note: the extension of your model file is the name of your metamodel)
				<mediaobject>
					<imageobject>
						<imagedata
							fileref="Kermeta-FSMDslTutorial_figures/19_name_model_editor.png"
							format="PNG" />
					</imageobject>
				</mediaobject>
				Set "FSM" as a type of object model.
				<mediaobject>
					<imageobject>
						<imagedata
							fileref="Kermeta-FSMDslTutorial_figures/20_type_model_editor.png"
							format="PNG" />
					</imageobject>
				</mediaobject>
				Then you can add elements in the model with right clic -> New Child. Your editor will propose you object of the right allowing type.
				<mediaobject>
					<imageobject>
						<imagedata
							fileref="Kermeta-FSMDslTutorial_figures/21_edit_model.png"
							format="PNG" />
					</imageobject>
				</mediaobject>
			</para>
			
			<para>Congratulation you have build a simple editor from your metamodel !</para>
		</section>
		<para>For more informations about EMF modeling go to "http://www.eclipse.org/documentation/", chose your version of Eclipse and select EMF Developer Guide -> Tutorials</para>
	</chapter>
	
	<chapter>
		<title>Adding constraints on the model</title>
		<para> TODO: not yet working on K2 but explain the OCL-like feature and for what is it. Ex: not duplicated transitions allowed</para>
		<section id="Creation of the project">
			<title>Creation of the project</title>
		</section>
		<section>
			<title>Run configurations</title>
			<section>
				<title>An entry point for the program</title>
			</section>
			<section>
				<title>Execution without parameters</title>
			</section>
			<section>
				<title>Execution with parameter(s)</title>
			</section>
		</section>
	</chapter>
	
	<chapter>
		<title>Make the machine alive</title>
		<para> TODO: explain how to write the interpreter and what is it</para>
		<section id="Adding behavior">
			<title>Adding behavior in theory</title>
			<section id="Expercted behavior">
				<title>Expected behaviour for this tutorial</title>
				<para>
					Adding a behaviour to the FSM meta-model consists in to make a simulation of execution with operations and an execution context represented by the current state of the FSM. That's why you need to add a currentState reference and three operation : 
					<itemizedlist>
						<listitem>
							<para>run() for FSM class</para>
						</listitem>
						<listitem>
							<para>step(String): String for State class</para>
						</listitem>
						<listitem>
							<para>and fire(): String for Transition class </para>
						</listitem>
					</itemizedlist>
					Adding behavior to this meta model look like change the meta model according the following schema : 					
					<mediaobject>
						<imageobject>
							<imagedata
								fileref="Kermeta-FSMDslTutorial_figures/FSMBehaviorMM.png"
								format="PNG" />
						</imageobject>
					</mediaobject>
				</para>
			</section>
			<section id="Behavior algorithms">
				<title>Behavior algorithms</title>
				<section>
					<title>Run algorithm</title>
					<itemizedlist>
						<listitem>
							<para>initialize current state</para>
						</listitem>
						<listitem>
							<para>
							loop until the user's input equal to "quit"
							<itemizedlist>
								<listitem>print the current state</listitem>
								<listitem>read a string</listitem>
								<listitem>process a step</listitem>
								<listitem>catch exceptions if there are some and exit the program displaying the error</listitem>
							</itemizedlist>
							</para>
						</listitem>
					</itemizedlist>
				</section>
				<section>
					<title>Step algorithm </title>
					<itemizedlist>
						<listitem>
							<para>Select the possible transitions</para>
						</listitem>
						<listitem>
							<para>If there is none</para>
							<itemizedlist>
								<listitem><para>Raise a NoTransition exception</para></listitem>
							</itemizedlist>
						</listitem>
						<listitem>
							<para>If there is more than one</para>
							<itemizedlist>
								<listitem><para>Raise a NonDeterminism exception</para></listitem>
							</itemizedlist>
						</listitem>
						<listitem>
							<para>If there is only one transition</para>
							<itemizedlist>
								<listitem><para>Call its fire operation and return its result</para></listitem>
							</itemizedlist>
						</listitem>
					</itemizedlist>
				</section>
				<section>
					<title>Fire algorithm </title>
					<para>
						<itemizedlist>
							<listitem>Change the current state of the FSM</listitem>
							<listitem>Return the produced string</listitem>
						</itemizedlist>
					</para>
				</section>
			</section>
			<section id="Aspect behavior">
				<title>Add this behavior with aspects</title>
				<para>
					Kermeta offer a simple way to implement behavior: the aspects.
					With aspect, you can add new elements and new operations to a fixed meta-model. 
					You can also combine several aspects. This section show you how to add behaviour with aspect into a metamodel.
				</para>
				<para>
					We illustrate this by an example on the FSM class:
					<programlisting language="kermeta">
using fsm::*
using kermeta::standard::*
using kermeta::io::StdIO => stdio

aspect class FSM 
{

	reference currentState : State
	
	operation run() :  Void raises FSMException is do 
		// [...]
	 end 
	
	operation initialize(p_state : State, isInitComb : Boolean) is do
		// [...]
	end 
} 
					</programlisting>
					<itemizedlist>
						<listitem>
							<para>The key word using permits to simplify the writing of the elements from the fsm meta model like an import in the Java language.</para>
						</listitem>
						<listitem>
							<para>The key word aspect is used to add attributes or operations to an existing metaclass of the loaded meta model.</para>
						</listitem>
					</itemizedlist>
				</para>
			</section>
		</section>
		<section id="Adding behavior K2">
			<title>Adding behavior in Kermeta 2</title>
			<section id="Creation of the project K2">
				<title>Creation of the project</title>
				<para>
					First create a new Kermeta 2 project in File -> New -> Project -> Kermeta -> Kermeta project.
					<mediaobject>
						<imageobject>
							<imagedata
								fileref="Kermeta-FSMDslTutorial_figures/22_create_kermeta_project.png"
								format="PNG" />
						</imageobject>
					</mediaobject>
					And name it "simulation"
					<mediaobject>
						<imageobject>
							<imagedata
								fileref="Kermeta-FSMDslTutorial_figures/23_name_kermeta_project.png"
								format="PNG" />
						</imageobject>
					</mediaobject>
				</para>
				
				<para>The project contains "project.kp" and "src/main/kmt/MainClass.kmt".</para>
				
				<para>
				"MainClass.kmt" define one method which print "Hello world!". 
				<programlisting language="kermeta">
using kermeta::standard::*
using kermeta::io::StdIO => stdio

package mainPackage{
	class MainClass
	{

		@main "" // declares that operation as a possible entry point of the program
		operation mainOperation() : Void is do 
			// TODO: implement 'mainOperation' operation
			stdio.writeln("Hello from mainOperation")
		end
	}
}
				</programlisting>
				</para>
				
				<para>
				The "project.kp" declare all the content of your project:
				<itemizedlist>
					<listitem>Import the kermeta metamodel where are defined all elements of the language</listitem>
					<listitem>Where is the main method</listitem>
					<listitem>"MainClass.kmt" is a source file of your project</listitem>
				</itemizedlist> 
				<programlisting language="kermeta">
resource library_standard ="platform:/plugin/org.kermeta.language.library.standard" alternative "mvn:org.kermeta.language/org.kermeta.language.library.standard/2.0.99-SNAPSHOT"
importProject library_standard
project simulation {
	mainClass "simulation^mainPackage::MainClass"
	mainOperation "mainOperation"

	import "${project.baseUri}/src/main/kmt/MainClass.kmt"
}
				</programlisting> 
				</para>
				
				<para>
				Now we want to import our model. To do that we add a ressource delcaration at the top of the kp:
				<programlisting language="kermeta">
resource fsm_model = "mvn:org.kermeta.language.sample.fsm/org.kermeta.language.sample.fsm.model/1.0.0-SNAPSHOT"
				</programlisting>
				Then we say to Kermeta this model is a part of our application by adding:
				<programlisting language="kermeta">
import "${fsm_model.baseUri}/model/fsm.ecore" using EMFBytecode(fsm_model)
				</programlisting>
				</para>
				
				<para>
				Now right clic on your project.kp -> clean and build. Then in the target folder open "beforeCheckingforScopeRESOLVED.km". This is the final model generated by the Kermeta 2 compilator. It is a reflect of the assemblage defined in the "project.kp".
				You can see two metamodels: kermeta and your own. Open yours to see the FSM model was successfully imported. Congratulation! 
				</para>
			</section>
			<section id="Implementation">
				<title>Write aspects on the classes</title>
				Right clic on your project New -> Other -> Kermeta -> Kermeta File.
				<mediaobject>
					<imageobject>
						<imagedata
							fileref="Kermeta-FSMDslTutorial_figures/24_create_new_kermeta_file.png"
							format="PNG" />
					</imageobject>
				</mediaobject>
				Rename it "fsm_Operationnal_Semantics.kmt".
				<mediaobject>
					<imageobject>
						<imagedata
							fileref="Kermeta-FSMDslTutorial_figures/25_name_new_kermeta_file.png"
							format="PNG" />
					</imageobject>
				</mediaobject>
				And add it in the "project.kp":
				<programlisting language="kermeta">
import "${project.baseUri}/src/main/kmt/fsm_Operationnal_Semantics.kmt"
				</programlisting>
				Then you can write aspect on the metaclasses to add the behavior:
				<programlisting language="kermeta">
using fsm::*
using kermeta::standard::*
using kermeta::io::StdIO => stdio
using kermeta::persistence::*
using kermeta::exceptions::*

package fsm{

	aspect class FSM 
	{
	
	//attribute ownedState : oset State[0..*]#owningFSM
		//reference initialState : Transition[1..*] 
		//reference finalState : State[0..*]
		reference currentState : State

		  
		// Operational semantic
		operation run() :  Void is do  
			// reset if there is no current state
			if self.currentState == void then self.currentState := self.initialState end
			self
			from var str : String init "init"
			until str == "quit"
			loop
				stdio.writeln("Current state : " + self.currentState.name)
				str := stdio.read("give me a letter : ")
				if str == "quit" then
					stdio.writeln("")
					stdio.writeln("quitting ...")
				else 
					if str == "print" then
						stdio.writeln("")
					else	
						stdio.writeln(str)			
						stdio.writeln("stepping...")
						do
							var textRes : String
							textRes := self.currentState.step(str)
							if( textRes == void or textRes == "" )
							then
								textRes := "NC"
							end
							
							stdio.writeln("string produced : " + textRes)
						
							rescue (err : ConstraintViolatedPre)
			            		stdio.writeln(err.toString)
			            		stdio.writeln(err.message)
			            		str := "quit"
			            	rescue (err : ConstraintViolatedPost)
		            			stdio.writeln(err.toString)
		            			stdio.writeln(err.message)
		            			str := "quit"
		            		
							rescue(err : NonDeterminism)
								stdio.writeln(err.toString)
								str := "quit"	
							rescue(err : NoTransition)
								stdio.writeln(err.toString)
								str := "quit"
		            	end
					end
				end
			end
		end
		
		/** Initialize a new automaton from an existing one 
		 *  param :
		 *    p_state : the initial state
		 *    isInitComb
		 */
		operation initialize(p_state : State, isInitComb : Boolean) is do
			var initState : State init p_state.copy
			ownedState.add(initState)
			initialState := initState 
			if (isInitComb == true) then initialState.combination := Set&lt;State&gt;.new end 
		end
		
	}
	
	aspect class State {
		
			reference combination : Set&lt;State&gt;
		
	
		// Go to the next state
		operation step(c : String) : String
		is do
			// Get the valid transitions
			var validTransitions : Collection&lt;Transition&gt; 
			validTransitions :=	outgoingTransition.select { t | t.input.equals(c) }
			// Check if there is one and only one valid transition
			if validTransitions.empty then raise NoTransition.new end
			if validTransitions.size > 1 then raise NonDeterminism.new end
			
			// Fire the transition
			result := validTransitions.one.fire
		end
		
		// Create a new state from self state
		operation copy() : State is do
			result := State.new
			result.name := ""+name //clone
			result.combination := Set&lt;State&gt;.new
		end
	}
	
	aspect class Transition 
	{	
		
		// Fire the transition
		operation fire() : String is do
			// update FSM current state
			source.owningFSM.currentState := target
			result := output
		end
	}
	
	abstract class FSMException inherits Exception{}
	class NonDeterminism inherits FSMException {}
	class NoTransition inherits FSMException {}
	class NoInitialStateException inherits FSMException{}

}
				</programlisting>
				
			</section>
			<section id="Write the simulation">
				<title>Write the simulation</title>
				<para>
				Add another Kermeta File in your project and name it "fsmLauncher.kmt". Don't forget the "project.kp":
				<programlisting language="kermeta">
import "${project.baseUri}/src/main/kmt/fsmLauncher.kmt"
				</programlisting>
				This file will contains the simulator, which will call operations from your aspects.
				As an entry point of your program it contains also the main method ( fix your "project.kp" if needed ;) ) and a method to load an instance model of your metamodel.
				<programlisting language="kermeta">
using fsm::*
using kermeta::standard::*
using kermeta::io::StdIO => stdio
using kermeta::emfpersistence::*
using kermeta::exceptions::*

package fsm{
	
	class Main
	{
		@main ""
		operation mainloadFSM(input_automaton : String) : Void is do
			var theFSM : FSM init loadfsm(input_automaton)
			printFSM(theFSM)
			theFSM.run()
		end
		
		 /*
		 * Load the FSM model from the xmi file sample1.fsm
		 * It's an instance of the FSM metamodel
		 * "../models/sample1.fsm"
		 */
		operation loadfsm(input_automaton : String) : FSM is do
			var rep : ResourceSet init ResourceSet.new
			result := AutomatonHelper.new.loadEMFAutomaton(rep, input_automaton, "http://www.kermeta.org/fsm")
	        
	        // Uncomment to check the invariant properties : WFR
	        // To check all contained elements by "result"
	        //result.checkAllInvariants
	        // To check only the states that are contained in "result"
	        //checkWFR(result)
		end

		/**
		 * For all states, we check the Well-Formedness rules
		 */
		operation checkWFR(theFSM : FSM) is do
			stdio.writeln("Check WFR : start")
			theFSM.ownedState.each{ s | 
				do
					// Call the invariant verification
					s.checkInvariants
					rescue (err : ConstraintViolatedInv)
			            stdio.writeln(err.toString)
			            stdio.write(err.message)
			            stdio.writeln(" on " + s.name)
			    end
			}
			stdio.writeln("Check WFR : end")
		end
		
		
		/**
		 * Print the FSM on the standard output
		 */
		operation printFSM(fsm : FSM) is do
			fsm.ownedState.each 
			{ s | 
				stdio.writeln("State : " + s.name)
				s.outgoingTransition.each { t | 
					var outputText : String
					if( t.output != void and t.output != "" )
						then outputText := t.output
						else outputText := "NC"
					end
					stdio.writeln("  Transition : " + t.source.name + "-(" + t.input + "/" + outputText + ")->" + t.target.name)
				}
			}
		end
	
	}
}
				</programlisting>
				AutomatonHelper is an object defined in "fsm_Helper.kmt" from the "org.kermeta.language.sample.fsm.simulation" project. It provide useful operations like save  and load model.
				
				TODO: speak about loading model
				</para>
			</section>
			<section id="Run the simulation">
				<title>Run the simulation</title>
				<para>
				TODO: config the eclipse launcher
				</para>
				<para>
				In this example we execute a step into the fsm behaviour algorithm with the file samplerun.fsm stored into org.kermeta.language.sample.fsm.model/models/samplerun.fsm.

				You use the transition c to go to s1 to s2 and produce the string v. The behaviour can be produced thanks to the operations run(), step() and fire() defined in the last section.
				
				You should obtain the following trace : 
				<mediaobject>
					<imageobject>
						<imagedata
							fileref="Kermeta-FSMDslTutorial_figures/result_example_behaviour.png"
							format="PNG" />
					</imageobject>
				</mediaobject>
				</para>
			</section>
		</section>
	</chapter>
	
	<chapter>
		<title>Model transformation</title>
		<para> TODO </para>
		<section id="determinization">
			<title>Determinization</title>
			<para>TODO</para>
		</section>
		<section id="minimization">
			<title>Minimization</title>
			<para>Delete duplicated states</para>
		</section>
	</chapter>
	
	<chapter>
		<title>Overview</title>
		<para>TODO: this is the result of the tuto</para>
		<section>
			<title>What you get at the end</title>
		</section>
		<section>
			<title>Getting the solution: the FSM sample</title>
			<para>Kermeta 2 provides a set of examples to show his skills. Among them you can retrieve the FSM sample, which will install Kermeta 2 projects in your workspace. You will find into them, as a support of this tutorial, the working source code. To do this just go in File -> New -> Example and then select "Kermeta 2 FSM sample" in "Kermeta 2 samples"</para>
		</section>
	</chapter>

</book>
			